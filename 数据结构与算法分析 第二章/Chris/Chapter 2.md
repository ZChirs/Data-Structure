# 周末交第一章作业

##一、 斐波那契数列、最大子序列和、二叉搜索分别见程序： Fibonacci、MaxSubsequence 和 BinarySearch。

##二、 练习
###     1.1.  按照增长率升序排序：
####        2/N
####        37
####        √N
####        N
####        N log log N
####        N log N
####        N log(N^2)
####        N (log N) ^ 2
####        N^1.5
####        N^2
####        N^2 * log N
####        N^3
####        2^(N / 2)
####        2^N
####        其中， N * log(N ^ 2) 和 N * log (N) 是以相同的增长率增长的， 因为 N * log(N ^ 2) = 2 * N * log(N), 忽略常数系数 2， 则这两个函数增长率相同。

###     2.2.  a 成立， 见 2.1 中的法则1;
###     2.3.  其实就是比较 log(N) 和 N^(ε / √㏒N) 的增长率. 两边同时做 log 运算， 即 log (log(N)) 和 log (N^(ε / √㏒N)), 第二个式子根据第一章的对数公式可以得出，log (N^(ε / √㏒N)) = (ε / √㏒N) * log (N) = ε * √㏒N. 设 log(N) = x, 那么两个式子分别为 log(x), ε√x.接下来的任务就是对比 log(x) 和 ε√x 的增长率了， 再将两边做平方运算， 两式子变成 (log(x))^2 和 ε^2 * x. 所以，可以 第一个函数的增长率要快于第二个函数。
###     2.4.  需要极限方面的知识，搁置。
###     2.5.  看题干没大看懂， 看了眼答案才知道问的是什么， 大概的意思就是有没有这样的两个函数 f(N) 和 g(N)，f(N) 不比 g(N) 大，也不比 g(n) 小， 即 f(N) 和 g(N) 无法用大 O 表示法来判断时间复杂度。
####        这里我就直接给出课后答案了， f(N) 和 g(N) 是两个分段函数， 大概长这样：
``
    int f(int n) {
        if (n % 2 == 0)
            return 0;
        return n;
    }

    int g(int n) {
        if (n % 2 == 0)
            return N;
        return 0;
    }
``
####        如上述两个函数，就无法用大 O 来判断增长率了，因为它们摇摆不定。
###     2.6.  a. (1) ~ (6) 时间复杂度分别为：1. O(N), 2. O(N^2), 3. O(N^3), 4. O(N^2), 5. O(N^5), 6. O(N^4); 执行程序见 习题2.6. 
####          关于 (6) 段代码， 第二层的 for (j = 1; j < i * i, j++) 与其循环内部的 if (j % i == 0) 抵消了一层， 或者说第二段的 for 是 O(N ^ 2)，但是循环体 if 语句是 O(N)的， 因为只有 j == i 的时候， 语句才成立，所以第二个 for 循环看上去是 O(N^2)， 但是循环体 O(N)， 所以, 由内向外计算， 最后一个 for 循环是 O(N^2)，第二个 for 是 O(N)，第一个 for 是 O(N)，所以答案是 O(N^4)。
###     2.7. 见程序 习题2.7.
####          a. 这些程序显然都是正确的。 对于 算法1 和 算法2 就像定义所描述的那样，如果真的要证明的话， 用归纳法？ N 是正确的， N+1 也是正确的；对于 程序3 ，因为初始化就是前 n 个自然数，然后顺序将其集合内每一个数和另一个随机位数的数做交换，所以交换之后也是正确的，等可能的。
####          b. 时间复杂度（大 O ）: 首先 算法3 是最清晰的线性时间 O(N)； 对于 算法1 ，如果 N = 1，那么时间是 O (1)，如果 N > 1，生成和第 i 个不重复的数字需要运行 N / (N - i) 次， 所以执行次数是 N / (N - i), (i > 0, i < N) 的级数, 经过计算 为 O(N ^ 2 * log(N))； 对于 算法2， 少了一层循环判断前 i - 1 个数字是否有重复， 所以时间复杂度是  O (N * log(N))。
####          c, d. 分析：算法 3 最容易， 是线性的; 算法 2 随着 N 的翻倍， 至少翻倍还要多一些； 算法1 随着 N 的翻倍，运行时间会涨的很快，也就是 O(N^2 log(N)) 。下面是我测试的一组运行时间（cpu 运行时间）平局数：
#####           算法1： N      平均运行时间
#####                 250       464.0
#####                 500       2103.5
#####                 1000      8511.3
#####                 2000      40157.2

#####           算法2   N      平均运行时间
#####                 2500      941.2
#####                 5000      1864.0
#####                 10000     3937.0
#####                 20000     9444.7
#####                 40000     18015.5
#####                 80000     37136.0

#####           算法3   N      平均运行时间
#####                 10000      474.2
#####                 20000      923.8
#####                 40000      1647.0
#####                 80000      3393.6
#####                 160000     7513.6
#####                 320000     16584.2
#####                 640000     37272.2

####          e. 算法 3 是线性的， 随意没有最好最坏； 算法 1 和 算法 2 最坏的情形就是永远也不能得到不重复的随机数，那么就会消耗非常大的资源，永远不会返回。
###     2.8. 见程序 习题 MaxSubsequence. 我的假设是 当 N = 100,0000 时，算法4 （线性时间）需要的时间只是翻了十倍，而 算法3 （会翻十倍多）， 算法1 、算法2 都将不能得到结果， 因为需要时间太长。
###     2.9. 见程序 习题 2.9, 2.10.
####          a. 首先 pow_loop 最多执行 N 次， normalSum 中的 for 循环执行了 N 次， 所以复杂度是 O(N^2);
####          b. pow_square 复杂度是 O(log(N))， for 循环执行了 N 次，所以复杂度是 O(N * log(N))。
###     2.10. 见程序 习题 2.9, 2.10.
####          a. 数组 A = {4, 8, 0, 1, 2}; N = 4, X = 3. 
#####           计算步骤:
#####                   ① 3 * 0 + A[4] 
#####                   ② 3 * ① + A[3]
#####                   ③ 3 * ② + A[2] 
#####                   ④ 3 * ③ + A[1]
#####                   ⑤ 3 * ④ + A[0]
####          将这个顺序展开就是： 3 * (3 * (3 * (3 * (3 * 0 + A[4]) + A[3]) + A[2]) + A[1]) + A[0]. 展开就得到了 A[N] * X^N 的级数; 
####          b. Horner 法则（霍纳法则）的意思就是说， 每一层抽取出一个 X。即 normalSum = a[n] * x^n + a[n - 1] * x ^ (n - 1) + ... + a[0] * x ^ 0 = a[n] * x^n + a[n - 1] * x ^ (n - 1) + ... + a[0] = x * (a[n] * x ^(n - 1) + a[n - 1] * x (n - 2) + ...) + a[0] = x * ( x * (a[n] * x ^ (n - 2) + a[n - 1] * x ^ (n - 3) + ...)) + a[0] = ... 最终结果长成这样 (((……(((a[n] + a[n-1]) * x + a[n-2]) * x+a[n-3]) * x)+……) * x+ a[1]) * x+ a[0]； 
####          c. 时间复杂度显然是 O(N)，因为省去了计算幂运算。
###     2.11. 二叉搜索， 见程序 BinarySearch。
###     2.12. 见程序 习题2.12.
####          a 是线性复杂度 O(N)；
####          b 见函数 minPositiveSubsequence(), 其函数由两个 O(N) 的 for 循环、 一个 O(N*log(N)) 快速排序以及 O(c) 常数操作组成，其复杂度也就是快速排序的复杂度， O(N*log(N))， 最坏为 O(N^2)。解析：累计计算前 n 项的和，得到一个 index 对应前 n 项和的集合，我们成为 Item，每一个 Item 有两个成员，一个是对应的索引 index (第几次计算)， 另一个是 value (前 index - 1 个 array 元素的和), 我们称这个集合是 Items。那么 Item[0] 是 0， item[1] = 0 + array[0], item[2] = 0 + array[0] + array[1], item[n - 1] = 0 + array[0] + array[1] + ... + array[n - 1]; 这样， items[i] 和 items[j] (i > j) 的 value 的差， 就是 array 第 j 项到第 i - 1 项的和；理解了这个之后，我们对 Items 按照 value 升序排序，排序之后，我们只需依次计算 items[i] - items[i - 1]的值，就可以求出最小的正整数和了，但是有个前提就是一定是 [items][i].index > items[i - 1].index，因为这样才保证了顺序， 否则的话， items[5] - items[7] ，也就是前 5 项的和减去前 7 项的和是求什么呢？相反数么？也就是说我们在保证求得是一个子序列的和，再计算出最小的正子序列和;  
####          c. 会用到别的思想，暂且搁置， 感兴趣的可以查查。
###     2.13. 确定一个正整数 N 是否是素数（质数）
####          a. 见程序 习题2.13.
####          b. 最坏的情况下是 O(√N); 也就是 for 循环中的 i * i ，因为每次 i += 6，所以最多执行的次数就是 (√N - 5) / 6 次， 所以是 O(√N);
####          c. B = O(log(N));
####          d. 如果 20 位运行时间是 T, 那么 40 位的运行时间就是 T^2;
####          e. 二进制更合理，因为更准确。
###     2.14. 搁置。
###     2.15. 先计算 X2 = X * X; X4 = X2 * X2 = X^4; X8 = X4 * X4 = X^8; X10 = X2 * X8; X20 = X10 * X10; X40 = X20 * X20; X60 = X40 * X20; X62 = X2 * X60; 只需要八次乘法。
###     2.16. 见程序 习题2.16.
###     2.17. 搁置。
###     2.18.
####          a. 程序A;
####          b. 程序B;
####          c. 不确定， 因为我们只有最坏的情况;
####          d. 搁置， 没看懂..
###     2.22. 不能， 会出现死循环，如果 low = 1, high = 2; mid = 1; ==> low = mid = 1; high = 2; mid = 1; ===> low = 1; high = 2; mid = 1; ...
###     2.23. 没明白题意...
###     2.24. 不能， low = 1, high = 2 的时候， 不会有任何执行。
